name: Auto Labeler (Unified Rules)

on:
  pull_request:
    types: [opened, edited, synchronize]

jobs:
  auto-label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Apply Labels from labeling-rules.json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Load rules
            const rulesPath = '.github/pr-lint/labeling-rules.json';
            if (!fs.existsSync(rulesPath)) {
              console.log('No labeling rules found at', rulesPath);
              return;
            }
            const rules = JSON.parse(fs.readFileSync(rulesPath, 'utf8'));

            // PR info
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const sourceBranch = pr.head.ref;
            const title = pr.title || '';
            const body = pr.body || '';

            const add = new Set();

            // Branch-based labels
            try {
              const branchGroups = rules.branch_patterns?.rules || {};
              for (const [_, group] of Object.entries(branchGroups)) {
                const patterns = group.patterns || [];
                for (const pat of patterns) {
                  const re = new RegExp(pat, 'i');
                  if (re.test(sourceBranch)) {
                    (group.labels || []).forEach(l => add.add(l));
                    break;
                  }
                }
              }
            } catch (e) {
              console.log('Branch pattern processing error:', e.message);
            }

            // Title-based labels: conventional + korean + priority + size
            try {
              const tp = rules.title_patterns || {};
              const parts = [
                ...(Object.values(tp.conventional_commits || {})),
                ...(Object.values(tp.korean_patterns || {})),
              ];
              for (const entry of parts) {
                if (!entry?.pattern || !entry?.labels) continue;
                const re = new RegExp(entry.pattern, 'i');
                if (re.test(title)) (entry.labels || []).forEach(l => add.add(l));
              }
              // priority
              if (tp.priority_keywords?.high?.pattern) {
                const re = new RegExp(tp.priority_keywords.high.pattern, 'i');
                if (re.test(title)) (tp.priority_keywords.high.labels || []).forEach(l => add.add(l));
              }
              // size indicators
              const size = tp.size_indicators || {};
              for (const k of Object.keys(size)) {
                const entry = size[k];
                if (!entry?.pattern) continue;
                const re = new RegExp(entry.pattern, 'i');
                if (re.test(title)) (entry.labels || []).forEach(l => add.add(l));
              }
            } catch (e) {
              console.log('Title pattern processing error:', e.message);
            }

            // Content-based labels: template detection + backmerge + breaking changes (optional)
            try {
              const ca = rules.content_analysis || {};
              const td = ca.template_detection || {};
              for (const key of Object.keys(td)) {
                const patterns = td[key]?.patterns || [];
                const labels = td[key]?.labels || [];
                if (patterns.some(p => new RegExp(p, 'i').test(body))) {
                  labels.forEach(l => add.add(l));
                }
              }
              // Breaking changes
              if (ca.breaking_changes?.patterns) {
                const bc = ca.breaking_changes;
                if ((bc.patterns || []).some(p => new RegExp(p, 'i').test(title) || new RegExp(p, 'i').test(body))) {
                  (bc.labels || []).forEach(l => add.add(l));
                }
              }
            } catch (e) {
              console.log('Content analysis processing error:', e.message);
            }

            const labels = Array.from(add);
            if (labels.length === 0) {
              console.log('No labels to add');
              return;
            }

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              labels,
            });
            console.log('Applied labels:', labels);
