name: Auto Labeler

on:
  pull_request:
    types: [opened, edited, synchronize]
  workflow_run:
    workflows: ["PR Template Selector & Auto Assignment"]
    types: [completed]
    
jobs:
  auto-label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Get PR Info
        id: pr-info
        uses: actions/github-script@v7
        with:
          script: |
            let prInfo = {};
            
            if (context.eventName === 'workflow_run') {
              // workflow_runì—ì„œëŠ” ì›ë³¸ PR ì •ë³´ë¥¼ ê°€ì ¸ì™€ì•¼ í•¨
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`,
                state: 'open'
              });
              
              if (prs.data.length > 0) {
                const pr = prs.data[0];
                prInfo = {
                  number: pr.number,
                  sourceBranch: pr.head.ref,
                  targetBranch: pr.base.ref,
                  title: pr.title,
                  body: pr.body || ''
                };
              } else {
                console.log('No matching PR found for workflow_run');
                return;
              }
            } else {
              // ì§ì ‘ PR ì´ë²¤íŠ¸ì¸ ê²½ìš°
              prInfo = {
                number: context.payload.pull_request.number,
                sourceBranch: context.payload.pull_request.head.ref,
                targetBranch: context.payload.pull_request.base.ref,
                title: context.payload.pull_request.title,
                body: context.payload.pull_request.body || ''
              };
            }
            
            // ì•ˆì „í•œ ë¬¸ìì—´ ì²˜ë¦¬ë¥¼ ìœ„í•´ JSONìœ¼ë¡œ ì €ì¥
            core.setOutput('pr-info', JSON.stringify(prInfo));
            console.log('ğŸ“‹ PR ì •ë³´:', prInfo.sourceBranch, 'â†’', prInfo.targetBranch, '(#' + prInfo.number + ')');
        
      - name: Auto Label by Branch
        if: steps.pr-info.outputs.pr-info
        uses: actions/github-script@v7
        env:
          PR_INFO: ${{ steps.pr-info.outputs.pr-info }}
        with:
          script: |
            // PR ì •ë³´ íŒŒì‹±
            const prInfo = JSON.parse(process.env.PR_INFO);
            
            // ë¸Œëœì¹˜ ê¸°ë°˜ ë¼ë²¨ë§ ê·œì¹™
            const branchLabels = {
              // ê¸°ëŠ¥ ê°œë°œ ë¸Œëœì¹˜
              '^feature/': ['type:feature'],
              '^feat/': ['type:feature'],
              
              // ë²„ê·¸ ìˆ˜ì • ë¸Œëœì¹˜
              '^fix/': ['type:fix'],
              '^bugfix/': ['type:fix'],
              
              // í•«í”½ìŠ¤ ë¸Œëœì¹˜
              '^hotfix/': ['type:hotfix', 'priority:high'],
              
              // ë¦´ë¦¬ìŠ¤ ë¸Œëœì¹˜
              '^release/': ['type:release', 'versioning:semver'],
              
              // ë™ê¸°í™” ë¸Œëœì¹˜
              '^sync/': ['sync:releaseâ†’develop'],
              
              // í¬ê¸°ë³„ ìë™ ë¶„ë¥˜ (ë¸Œëœì¹˜ëª… íŒ¨í„´)
              '/(xs|tiny|small)': ['size/XS'],
              '/(sm|medium)': ['size/S'],
              '/(md|large)': ['size/M'],
              '/(lg|huge)': ['size/L'],
              '/(xl|massive)': ['size/XL']
            };
            
            const labelsToAdd = [];
            
            // ë¸Œëœì¹˜ëª…ìœ¼ë¡œ ë¼ë²¨ ê²°ì •
            for (const [pattern, labels] of Object.entries(branchLabels)) {
              const regex = new RegExp(pattern, 'i');
              if (regex.test(prInfo.sourceBranch)) {
                labelsToAdd.push(...labels);
              }
            }
            
            // ì¤‘ë³µ ì œê±°
            const uniqueLabels = [...new Set(labelsToAdd)];
            
            if (uniqueLabels.length > 0) {
              console.log('ë¸Œëœì¹˜ì—ì„œ ê°ì§€ëœ ë¼ë²¨:', prInfo.sourceBranch, uniqueLabels);
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prInfo.number,
                labels: uniqueLabels
              });
            }
            
      - name: Auto Label by Title and Content
        if: steps.pr-info.outputs.pr-info
        uses: actions/github-script@v7
        env:
          PR_INFO: ${{ steps.pr-info.outputs.pr-info }}
        with:
          script: |
            // PR ì •ë³´ íŒŒì‹±
            const prInfo = JSON.parse(process.env.PR_INFO);
            const labelsToAdd = [];
            
            // ì œëª© ê¸°ë°˜ ë¼ë²¨ë§ ê·œì¹™ (type(scope): summary [TICKET] í˜•ì‹)
            const titleRules = {
              // Conventional Commits ìŠ¤íƒ€ì¼ (scope í¬í•¨)
              '^feat\\([^)]+\\):': ['type:feature'],
              '^fix\\([^)]+\\):': ['type:fix'],
              '^refactor\\([^)]+\\):': ['type:refactor'],
              '^perf\\([^)]+\\):': ['type:performance'],
              '^test\\([^)]+\\):': ['type:test'],
              '^docs\\([^)]+\\):': ['type:docs'],
              '^chore\\([^)]+\\):': ['type:chore'],
              
              // Scope ì—†ëŠ” ê²½ìš°
              '^feat:': ['type:feature'],
              '^fix:': ['type:fix'],
              '^refactor:': ['type:refactor'],
              '^perf:': ['type:performance'],
              '^test:': ['type:test'],
              '^docs:': ['type:docs'],
              '^chore:': ['type:chore'],
              '^release:': ['type:release'],
              
              // í•œêµ­ì–´ ì œëª© íŒ¨í„´
              '^(ê¸°ëŠ¥|feature)': ['type:feature'],
              '^(ìˆ˜ì •|fix|ë²„ê·¸)': ['type:fix'],
              '^(ë¦¬íŒ©í† ë§|refactor)': ['type:refactor'],
              '^(ì„±ëŠ¥|perf|ìµœì í™”)': ['type:performance'],
              '^(í…ŒìŠ¤íŠ¸|test)': ['type:test'],
              '^(ë¬¸ì„œ|docs|ë„íë¨¼íŠ¸)': ['type:docs'],
              '^(ì¡ë¬´|chore|ì„¤ì •)': ['type:chore'],
              '^(ë¦´ë¦¬ìŠ¤|release|ë°°í¬)': ['type:release'],
              
              // ìš°ì„ ìˆœìœ„ í‚¤ì›Œë“œ
              '(ê¸´ê¸‰|urgent|critical|hotfix)': ['priority:high'],
              '(ì¤‘ìš”|important|high)': ['priority:high'],
              
              // í¬ê¸° í‚¤ì›Œë“œ
              '(minor|ì‘ì€|ì†Œê·œëª¨)': ['size/XS'],
              '(small|ì‘ìŒ|ê°„ë‹¨)': ['size/S'],
              '(medium|ë³´í†µ|ì¤‘ê°„)': ['size/M'],
              '(large|í¼|ëŒ€ê·œëª¨)': ['size/L'],
              '(huge|ë§¤ìš°|ê±°ëŒ€)': ['size/XL'],
              
              // Breaking Changes
              '(breaking|!:|major)': ['versioning:semver'],
              
              // í‹°ì¼“ ë²ˆí˜¸ ê°ì§€
              '\\[PROJ-\\d+\\]': ['has-ticket'],
              '\\[\\w+-\\d+\\]': ['has-ticket'],
              
              // íŠ¹ìˆ˜ ìƒí™©
              '(override|ë¬´ì‹œ|ê°•ì œ)': ['guard:override']
            };
            
            // ì œëª©ìœ¼ë¡œ ë¼ë²¨ ê²°ì •
            for (const [pattern, labels] of Object.entries(titleRules)) {
              const regex = new RegExp(pattern, 'i');
              if (regex.test(prInfo.title)) {
                labelsToAdd.push(...labels);
              }
            }
            
            // PR ë³¸ë¬¸ ê¸°ë°˜ ë¼ë²¨ë§
            const bodyRules = {
              // í…œí”Œë¦¿ ê°ì§€
              'ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€|# ìƒˆë¡œìš´ ê¸°ëŠ¥': ['type:feature'],
              'ë²„ê·¸ ìˆ˜ì •|# ë²„ê·¸ ìˆ˜ì •': ['type:fix'],
              'ê¸´ê¸‰ í•«í”½ìŠ¤|# ê¸´ê¸‰ í•«í”½ìŠ¤': ['type:hotfix', 'priority:high'],
              'ë¦´ë¦¬ìŠ¤ \\(Main\\)|# ë¦´ë¦¬ìŠ¤ \\(Main\\)': ['type:release'],
              'ë¦´ë¦¬ìŠ¤ ë°±ë¨¸ì§€|# ë¦´ë¦¬ìŠ¤ ë°±ë¨¸ì§€': ['sync:releaseâ†’develop'],
              
              // ì²´í¬ë°•ìŠ¤ ì™„ì„±ë„ë¡œ í¬ê¸° ì¶”ì •
              '- \\[x\\]': 'CHECKBOX_COUNT',
              '- \\[ \\]': 'CHECKBOX_TOTAL'
            };
            
            // ë³¸ë¬¸ìœ¼ë¡œ ë¼ë²¨ ê²°ì •
            let checkedCount = 0;
            let totalCount = 0;
            
            for (const [pattern, labels] of Object.entries(bodyRules)) {
              const regex = new RegExp(pattern, 'gi');
              const matches = prInfo.body.match(regex);
              
              if (pattern === '- \\[x\\]') {
                checkedCount = matches ? matches.length : 0;
              } else if (pattern === '- \\[ \\]') {
                totalCount = matches ? matches.length : 0;
              } else if (matches && Array.isArray(labels)) {
                labelsToAdd.push(...labels);
              }
            }
            
            // ì²´í¬ë°•ìŠ¤ ì™„ì„±ë„ë¡œ í¬ê¸° ì¶”ì •
            const totalCheckboxes = checkedCount + totalCount;
            if (totalCheckboxes > 0) {
              if (totalCheckboxes <= 3) labelsToAdd.push('size/XS');
              else if (totalCheckboxes <= 6) labelsToAdd.push('size/S');
              else if (totalCheckboxes <= 10) labelsToAdd.push('size/M');
              else if (totalCheckboxes <= 15) labelsToAdd.push('size/L');
              else labelsToAdd.push('size/XL');
            }
            
            // ì¤‘ë³µ ì œê±°
            const uniqueLabels = [...new Set(labelsToAdd)];
            
            if (uniqueLabels.length > 0) {
              console.log('ì œëª©ì—ì„œ ê°ì§€ëœ ë¼ë²¨:', prInfo.title, uniqueLabels);
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prInfo.number,
                labels: uniqueLabels
              });
            }
            
      - name: Remove Conflicting Labels
        if: steps.pr-info.outputs.pr-info
        uses: actions/github-script@v7
        env:
          PR_INFO: ${{ steps.pr-info.outputs.pr-info }}
        with:
          script: |
            // PR ì •ë³´ íŒŒì‹±
            const prInfo = JSON.parse(process.env.PR_INFO);
            
            // ìƒì¶©ë˜ëŠ” ë¼ë²¨ ê·¸ë£¹ë“¤
            const conflictingGroups = [
              ['type:feature', 'type:fix', 'type:hotfix', 'type:release'],
              ['size/XS', 'size/S', 'size/M', 'size/L', 'size/XL'],
              ['priority:high', 'priority:medium', 'priority:low']
            ];
            
            // í˜„ì¬ PRì˜ ë¼ë²¨ ê°€ì ¸ì˜¤ê¸°
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number
            });
            
            const currentLabelNames = currentLabels.map(label => label.name);
            
            // ê° ê·¸ë£¹ì—ì„œ ì¤‘ë³µ ë¼ë²¨ ì œê±°
            for (const group of conflictingGroups) {
              const foundLabels = group.filter(label => currentLabelNames.includes(label));
              
              if (foundLabels.length > 1) {
                // ì²« ë²ˆì§¸ë¥¼ ì œì™¸í•˜ê³  ë‚˜ë¨¸ì§€ ì œê±°
                const labelsToRemove = foundLabels.slice(1);
                
                for (const labelToRemove of labelsToRemove) {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prInfo.number,
                    name: labelToRemove
                  });
                  console.log('ì¤‘ë³µ ë¼ë²¨ ì œê±°:', labelToRemove);
                }
              }
            }
