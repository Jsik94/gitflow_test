name: PR Auto Assign (Reviewers & Assignee)

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

jobs:
  auto-assign:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Auto assign reviewers and assignee
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const author = pr.user.login;
            const isDraft = !!pr.draft;

            // ê²°ê³¼ ìˆ˜ì§‘ ë¡œê·¸
            const result = {
              reviewersRequested: [],
              reviewerTeamsRequested: [],
              reviewersErrors: [],
              assigneeAdded: null,
              assigneeError: null,
              codeownersFound: false,
            };

            // 1) CODEOWNERS íŒŒì‹± ì‹œë„
            let codeownersText = '';
            try {
              const { data } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.github/CODEOWNERS'
              });
              codeownersText = Buffer.from(data.content, 'base64').toString('utf8');
              result.codeownersFound = true;
            } catch (e) {
              console.log('CODEOWNERS not found or inaccessible, continuing with fallbacks');
            }

            // 2) ë¦¬ë·°ì–´ í›„ë³´ ì¶”ì¶œ
            const reviewerUsers = new Set();
            const reviewerTeams = new Set(); // org/team

            if (codeownersText) {
              const lines = codeownersText.split('\n');
              for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line || line.startsWith('#')) continue;
                // íŒ¨í„´ ë’¤ì˜ ì†Œìœ ì ëª©ë¡ ì¶”ì¶œ
                const parts = line.split(/\s+/);
                if (parts.length < 2) continue;
                const owners = parts.slice(1);
                for (const owner of owners) {
                  if (!owner.startsWith('@')) continue;
                  const ident = owner.slice(1);
                  if (ident.includes('/')) {
                    // org/team í˜•íƒœ
                    reviewerTeams.add(ident);
                  } else {
                    // user
                    reviewerUsers.add(ident);
                  }
                }
              }
            }

            // ì‘ì„±ì ì œì™¸
            reviewerUsers.delete(author);

            // 3) ë¦¬ë·°ì–´ ìš”ì²­ (Draft PRì€ ìš”ì²­ ìŠ¤í‚µ)
            if (!isDraft) {
              try {
                // íŒ€ ë¦¬ë·°ì–´ëŠ” org/teamì—ì„œ team slugë§Œ ì¶”ì¶œ í•„ìš” (orgëŠ” ìë™ ì¸ì‹)
                const teamReviewersByOrg = {};
                for (const full of reviewerTeams) {
                  const [org, team] = full.split('/');
                  if (!org || !team) continue;
                  if (!teamReviewersByOrg[org]) teamReviewersByOrg[org] = new Set();
                  teamReviewersByOrg[org].add(team);
                }

                // GitHub APIëŠ” í•œ ë²ˆì— team_reviewersë¥¼ ë³´ë‚¼ ë•Œ org contextê°€ repo orgì™€ ê°™ì•„ì•¼ í•¨
                // ê°œì¸ ë ˆí¬ ë˜ëŠ” í¬í¬ì—ì„œëŠ” ì‹¤íŒ¨í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì‚¬ìš©ì ë¦¬ë·°ì–´ ë¨¼ì € ì‹œë„, íŒ€ ë¦¬ë·°ì–´ëŠ” best-effort

                // ì‚¬ìš©ì ë¦¬ë·°ì–´ ìš”ì²­
                const users = Array.from(reviewerUsers);
                if (users.length > 0) {
                  try {
                    await github.rest.pulls.requestReviewers({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      reviewers: users,
                    });
                    result.reviewersRequested.push(...users);
                  } catch (e) {
                    result.reviewersErrors.push(`users: ${e.message}`);
                  }
                }

                // íŒ€ ë¦¬ë·°ì–´ ìš”ì²­ (ë™ì¼ org ê¸°ì¤€ìœ¼ë¡œë§Œ ìš”ì²­ ê°€ëŠ¥ â†’ org ë‹¤ë¥´ë©´ ìŠ¤í‚µ)
                for (const [org, teamsSet] of Object.entries(teamReviewersByOrg)) {
                  const teams = Array.from(teamsSet);
                  try {
                    await github.rest.pulls.requestReviewers({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      team_reviewers: teams,
                    });
                    result.reviewerTeamsRequested.push(...teams.map(t => `${org}/${t}`));
                  } catch (e) {
                    result.reviewersErrors.push(`teams(${org}): ${e.message}`);
                  }
                }
              } catch (e) {
                result.reviewersErrors.push(`general: ${e.message}`);
              }
            } else {
              console.log('Draft PR detected: skipping reviewer request');
            }

            // 4) Assignee ìë™ ì„¤ì • (ë‹´ë‹¹ì ì—†ìœ¼ë©´ ì‘ì„±ì ì§€ì •)
            try {
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
              });
              const currentAssignees = (issue.assignees || []).map(u => u.login);
              if (currentAssignees.length === 0) {
                try {
                  await github.rest.issues.addAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    assignees: [author],
                  });
                  result.assigneeAdded = author;
                } catch (e) {
                  result.assigneeError = e.message;
                }
              } else {
                console.log('Assignees already set:', currentAssignees.join(', '));
              }
            } catch (e) {
              result.assigneeError = e.message;
            }

            // 5) ê²°ê³¼ ì½”ë©˜íŠ¸ (ì •ë³´ìš©)
            const lines = [];
            lines.push('ğŸ¤– **PR ìë™ ë°°ì • ê²°ê³¼**');
            lines.push('');
            lines.push(`- CODEOWNERS ì°¾ìŒ: ${result.codeownersFound ? 'âœ…' : 'âŒ'}`);
            if (!isDraft) {
              lines.push(`- ì‚¬ìš©ì ë¦¬ë·°ì–´ ìš”ì²­: ${result.reviewersRequested.length > 0 ? result.reviewersRequested.join(', ') : 'ì—†ìŒ'}`);
              lines.push(`- íŒ€ ë¦¬ë·°ì–´ ìš”ì²­: ${result.reviewerTeamsRequested.length > 0 ? result.reviewerTeamsRequested.join(', ') : 'ì—†ìŒ'}`);
              if (result.reviewersErrors.length > 0) {
                lines.push(`- ë¦¬ë·°ì–´ ìš”ì²­ ì˜¤ë¥˜: ${result.reviewersErrors.join(' | ')}`);
              }
            } else {
              lines.push('- Draft PR: ë¦¬ë·°ì–´ ìš”ì²­ ìƒëµ');
            }
            lines.push(`- ë‹´ë‹¹ì ì„¤ì •: ${result.assigneeAdded ? '@' + result.assigneeAdded : 'ë³€ê²½ ì—†ìŒ'}`);
            if (result.assigneeError) {
              lines.push(`- ë‹´ë‹¹ì ì„¤ì • ì˜¤ë¥˜: ${result.assigneeError}`);
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: lines.join('\n')
            });
